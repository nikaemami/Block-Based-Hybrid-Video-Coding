# -*- coding: utf-8 -*-
"""code_1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VtuWPND4cUBDDGQt340ZixncY0jONHuG
"""

# Commented out IPython magic to ensure Python compatibility.
import cv2
import numpy as np
import matplotlib.pyplot as plt
from tqdm import tqdm
# %matplotlib inline

"""This code implements a basic form of the block-based hybrid video coder for coding
a P-frame using a fixed block size of 8x8. For simplicity, we considered intra-prediction using only
the first 3 intra prediction modes shown below over 8x8 blocks, and inter-prediction using
integer accuracy EBMA, with a specified search range, e.g. +/-24. For inter-prediction, we used two frames that are 10 frames apart, and use the past frame to predict the future frame.
"""

img1 = cv2.imread('/Users/nikaemami/Downloads/CA06_upload/Football/frame30.jpg')
img1 = img1.astype('float')
# Load another frame that is 10 frames after the above frame
img2 = cv2.imread('/Users/nikaemami/Downloads/CA06_upload/Football/frame40.jpg')
img2 = img2.astype('float')

# Plot the two Frames
fig, ax = plt.subplots(1,2)
ax[0].imshow(img1, cmap='gray')
ax[1].imshow(img2, cmap='gray')
plt.show()

# Define a function to calculate the MSE with the error block as the input
def mse(error):
  mse = np.mean((error)**2)
  return mse

# Return the matching block and the motion vector
def EBMA(template,img,x0,y0,range_x,range_y):
    rows, cols = img.shape

    # get the number of rows and columns of the template
    b_rows, b_cols = template.shape

    # initialize maximum error, motion vector and matchblock
    min_mse = 1e8
    xm = 0
    ym = 0
    matchblock = np.zeros(template.shape)

    # loop over the searching range to find the matchblock with the smallest error:
    for j in range(max(1, y0 - range_y), min(cols - b_cols, y0 + range_y)):
        error = template - candidate
        mse_error = mse(error)
        if mse_error < min_mse:
            ym = j
            matchblock = candidate
            min_mse = mse_error

    return xm, ym, matchblock

# define quantization function to quantize the dct coefficients
def quant(dct_coef, q):
    dctimg_quant = np.floor((dct_coef+q/2)/q)*q
    return dctimg_quant

"""## Generate Predicted Image and Error Image
- We will be coding img2 with intraprediction using reconstructed pixels in the same frame, and interprediction using past frame img1 as reference
- We will assume that the first row and column of the image are already reconstructed.
- Also assume that in both inter and intraprediction, the reference pixels were perfectly reconstructed. So we can use the original pixels from img1 and img2 as reference in prediction.

- This section of code will generate two images:

    - **Predicted Image**: Image predicted via intra and inter modes using reference pixels from img2 and img1
    - **Error Image**: Unquantized image of the error between predicted image and original image
"""

# define searching range for EBMA
range_x = 25
range_y = 25

# get the row and column size of the images.
rows, cols = img2.shape
N=8

# Pad the right and bottom sides of image 2, so that the image dimensions (min
img2_pad = np.pad(img2, [[0,N-(rows-1)%N],[0,N-(cols-1)%N]], mode ='edge')

pred_img_pad = np.zeros_like(img2_pad)

pred_img_pad[0, :] = img2_pad[0, :]
pred_img_pad[:, 0] = img2_pad[:, 0]

err_img_pad = np.zeros_like(img2_pad)

for x0 in tqdm(np.arange(1, (rows - 1), N)):
    for y0 in np.arange(1, (cols - 1), N):
        # Extract the current block from the padded image
        patch = img2_pad[x0:x0 + N, y0:y0 + N]
        # Initialize the minimum Mean Squared Error (MSE) with a high value
        min_MSE = 255**2
        # Mode 0: Vertical Prediction
        pred_block = np.zeros((N, N))
        pred_block[:, 0] = img2_pad[x0 - 1:x0 - 1 + N, y0]
        err_block = patch - pred_block

        # Calculate MSE for the current error block
        current_mse = np.mean(err_block ** 2)

        # Update minimum MSE and corresponding predicted and error blocks
        if current_mse < min_MSE:
            min_pred_block = pred_block.copy()
            min_err_block = err_block.copy()
            min_MSE = current_mse


        # Mode 1: Horizontal Prediction
        pred_block = np.zeros((N, N))
        # Copy the last column of the previous block for horizontal prediction
        pred_block[0, :] = img2_pad[x0, y0 - 1:y0 - 1 + N]
        # Calculate and compare MSE for horizontal prediction
        err_block = patch - pred_block
        current_mse = np.mean(err_block ** 2)


        if current_mse < min_MSE:
            min_pred_block = pred_block.copy()
            min_err_block = err_block.copy()
            min_MSE = current_mse


        # Mode 2: DC Prediction
        pred_block = np.zeros((N, N))

        # Use the average value of the neighboring pixels for DC prediction
        pred_block[:, :] = np.mean(img2_pad[x0 - 1:x0 - 1 + N, y0 - 1:y0 - 1+ N])

        # Calculate and compare MSE for DC prediction
        err_block = patch - pred_block
        current_mse = np.mean(err_block ** 2)

        if current_mse < min_MSE:
            min_pred_block = pred_block.copy()
            min_err_block = err_block.copy()
            min_MSE = current_mse

        # Inter-Prediction using EBMA
        # Find the best matching block in the reference image (img1) using EBM
        xm, ym, pred_block = EBMA(patch, img1, x0, y0, range_x, range_y)

        # Calculate the error and MSE for the matched block
        err_block = patch - pred_block
        current_mse = np.mean(err_block ** 2)



        if current_mse < min_MSE:
            # Update the minimum MSE and corresponding blocks if the current M
            min_pred_block = pred_block.copy()
            min_err_block = err_block.copy()
            min_MSE = current_mse


        # Store the best prediction and corresponding error block in the outpu
        pred_img_pad[x0:x0 + N, y0:y0 + N] = min_pred_block
        err_img_pad[x0:x0 + N, y0:y0 + N] = min_err_block

# After processing all blocks, remove padding to get the final predicted and e
pred_img = pred_img_pad[0:rows, 0:cols]
err_img = err_img_pad[0:rows, 0:cols]

# plot the original image

plt.figure(figsize=(12, 4))
plt.subplot(1, 3, 1)
plt.imshow(img2, cmap='gray')
plt.title('Original Image')
plt.axis('off')

# Plot the predicted image
plt.subplot(1, 3, 2)
plt.imshow(pred_img, cmap='gray')
plt.title('Predicted Image')
plt.axis('off')

# Plot the error image
plt.subplot(1, 3, 3) plt.imshow(err_img, cmap='gray')
plt.title('Error Image')
plt.axis('off')
plt.show()

"""## Test different quantization step sizes
- Using the err_img_pad from above, quantize the error image with different step sizes. Then add to the predicted image to generate the reconstructed image. Test different step sizes and evaluate PSNR.
"""

# QUANTIZE WITH DIFFERENT STEP SIZE: 4, 16, 32, 64, 128
Q_list = [4, 16, 32, 64, 128]

# Lists to hold reconstructed image, non-zero counts, psnr
Rec_img =[]
Non_zero = []
PSNR = []

for q in Q_list:
    non_zero = 0
    rec_img_pad = np.zeros(img2_pad.shape)
    # Assume first row & col are already reconstructed, copy them directly form img2
    rec_img_pad[0, :] = img2_pad[0, :]
    rec_img_pad[:, 0] = img2_pad[:, 0]
    for x0 in np.arange(1,(rows-1), N):
        for y0 in np.arange(1,(cols-1), N):
            # extract current error block from the error image
            err_block = err_img_pad[x0:x0 + N, y0:y0 + N]
            # perform DCT to the current error block, input astype float
            dct_block = cv2.dct(np.float32(err_block))
            # quantize the coefficients
            dct_block_quant = quant(dct_block, q)
            # Count number of nonzero in this block, update nonzero
            non_zero += np.count_nonzero(dct_block_quant)
            # IDCT to the quantized dct block, input astype float
            err_block_rec = cv2.idct(dct_block_quant.astype('float32'))
            # reconstruct the block
            rec_img_pad[x0:x0 + N, y0:y0 + N] = rec_img_pad[x0:x0 + N, y0:y0 +N]
    # Remove padding
    rec_img = rec_img_pad[0:rows, 0:cols]

    # Calculate PSNR, Append items to lists
    mse = np.mean((img2 - rec_img) ** 2)
    psnr = 20 * np.log10(255 / np.sqrt(mse))

    PSNR.append(psnr)
    Non_zero.append(non_zero)
    # Clip rec_img to (0,255) and change back to uint8
    rec_img = np.clip(rec_img,0,255).astype('uint8')
    Rec_img.append(rec_img)

"""### Plot the PSNR vs. Nonzero curve, each Reconstructed image with different quantization steps"""

# Plot the PSNR vs. Nonzero curve, each Reconstructed image with different qua
plt.figure()
plt.plot(Non_zero, PSNR)
plt.title('PSNR vs Nonzero')
plt.xlabel('Num of Nonzero Coefficients')
plt.ylabel('PSNR (dB)')
plt.show()

# Plot each reconstructed image with different quantization steps
plt.figure()
for i, q in enumerate(Q_list):
plt.imshow(Rec_img[i], cmap='gray')
plt.title(f'Reconstructed with (q={q})')
plt.axis('off')
plt.show()

